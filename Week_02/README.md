## 作业1：

借鉴了其他同学运行命令行程序并获取java输出的python程序，并将原有java程序的`System.out.println`改为只输出数字 ：

```python
"""
GC分析测试脚本
"""
import os
import subprocess

if __name__ == "__main__":
    command = ["java", "xmx", "xms", "gc", "GCLogAnalysis"]

    for memory in ["128m", "512m", "1g", "2g", "4g", "8g"]:
        for gc in ["-XX:+UseSerialGC", "-XX:+UseParallelGC", "-XX:+UseConcMarkSweepGC", "-XX:+UseG1GC"]:
            xmx = "-Xmx" + memory
            xms = "-Xms" + memory
            command[1] = xmx
            command[2] = xms
            command[3] = gc

            # result = os.system(" ".join(command))
            try:
                spend = 0
                for _ in range(0, 10):
                    spend += int(subprocess.check_output(" ".join(command)))
                print(memory, gc, "::", spend / 10)
            except Exception as e:
                print(memory, gc, "::OOM")
```

**通过程序计算出各GC平均10次的创建对象次数**：

| 创建次数 | 128m | 512m   | 1g      | 2g     | 4g      | 8g     |
| -------- | ---- | ------ | ------- | ------ | ------- | ------ |
| 串行GC   | OOM  | 8444.8 | 8653.1  | 9144.4 | 7735.2  | 6032.5 |
| 并行GC   | OOM  | 7520.7 | 10906.8 | 9971.4 | 8559.8  | 6226.2 |
| CMSGC    | OOM  | 7961.5 | 10974.5 | 9191.7 | 10784.7 | 7198.6 |
| G1GC     | OOM  | 8431.7 | 9647.5  | 8213.3 | 13588   | 9738.2 |

根据表格可以看出，串行、并行 、CMS GC随着内存的增大，创建对象数有先增大后减少的趋势。

分析原因：随着内存增大，年轻代的容量也随之增大，GC次数减少，用户程序有更多的时间运行，但随着容量的增大，年轻代标记-复制的负担加重，每次运行GC的时间会变长。所以，创建对象次数出现先增大后减小的趋势符合预期。

而G1为何稳定，应该是和G1里面region的算法相关，这里第二节课还没听明白，所以先不做评述。

**接下来看一下吞吐量 GC总时间/ 1秒：**

| 吞吐量 | 128m | 512m | 1g   | 2g   | 4g   | 8g   |
| ------ | ---- | ---- | ---- | ---- | ---- | ---- |
| 串行GC | OOM  | 39%  | 29%  | 23%  | 无GC | 无GC |
| 并行GC | OOM  | 38%  | 25%  | 13%  | 无GC | 无GC |
| CMSGC  | OOM  | 32%  | 23%  | 25%  | 29%  | 37%  |
| G1GC   | OOM  | 24%  | 17%  | 35%  | 27%  | 20%  |

串行GC虽然2g比1g的GC次数少了，但明显单次GC的时间更长了。

CMSGC的初始化标记和最终标记的时间占非常少的暂停时间。但神奇的发现，CMS内存越大，后面单次GC的时间变长之外，4g和8g也还会发生youngGC，而且youngGC的吞吐量还有增大的趋势。但CMS的优势在于相比于FULL GC而言，它的延迟是真的低。

G1GC表现出的趋势就是平稳。

### 如何纵向比较各个GC算法呢？

我自己想了一下未果，然后上网查了一下，在一个博客上找到了思路：使用不同的GC算法对同一个程序进行压测，导出GC日志，统计GC的总时间，然后除以程序的总的运行时间，以此测算程序的吞吐量。然后，找一下最长的暂停时间。



## 作业2

使用压测工具superbenchmarker，演练gateway-server-0.0.1-SNAPSHOT.jar 示例。

分别测试串行、并行、CMS、G1等GC，内存测试分别为512M、1G、2G、4G

测试的数据如下：sb -u http://localhost:8088/api/hello -c 20 -N 60

| RPS  | 512M            | 1G             | 2G              | 4G              |
| ---- | --------------- | -------------- | --------------- | --------------- |
| 串行 | 252.3 （989ms） | 287.4（768ms） | 279.6（1016ms） | 270.9（1244ms） |
| 并行 | 291.5（847ms）  | 258.8（885ms） | 272.1（704ms）  | 267.2（1063ms） |
| CMS  | 285.9（1013ms） |                |                 | 303.9（311ms）  |
| G1   |                 |                |                 |                 |

有个疑问，决定RPS的到底是计算机的什么硬件？为啥

CMS在512M下比并行要快一些，而在4G的情况下，并行反而更好。因为CMS虽然延迟低，但整体GC占用的时间也在增加。

G1的吞吐量比并行的也要低

所以，默认用并行的GC是有价值的。





对象占用多少内存 。



由于对齐的存在，所以必须要浪费空间。



OOM的原因：

1. 堆不够用
2. meta区里面放的是类的定义。meta溢出。默认是无穷大。



并行GC

在分别使用-Xms128m -Xmx128m .... -Xms4096m -Xmx4096m的 时候，

-Xms128m -Xmx128m：频繁发生youngGC和FullGC，直到后面系统一直进行FullGC但old区的内存没有明显减少，系统的时间都用来做FullGC了，虽然没有OOM但和OOM差不多，生成对象的次数是1463

-Xms512m -Xmx512m：7次youngGC，生成对象数3231

-Xm1024m -Xmx1024m：3次youngGC，生成对象数3868

-Xm2048m -Xmx2048m：2次youngGC，生成对象数3929

-Xm4096m -Xmx4096m：没有GC，生成对象数2964



相同程序，使用不同GC算法，

能获得的信息有完成GC所消耗的时间，每次GC过后对象大小，以及每个区的内存占用率

然后，就比较一下这几个值么

生成对象：1463 年轻代占用率：45.56% 老年代：99.65% 总共耗时：0.7s 所有的real相加得到的，这么看来就是，只运行了0.3s的程序

生成对象：3231 年轻：

使用 GCLogAnalysis.java 自己演练一遍串行/并行/CMS/G1的案例，要看什么呢？看总共消耗时间是有意义的，因为 ，这样你就知道程序的运行时间了。使用不同的内存去运行是有意义的，因为，在不同内存下，你可以看同一个GC的在不同内存下的不同表现，以及最好分析一下为什么有这样的表现。

对于并行GC而言，我们看到，随着-Xmx的增大，虽然GC的次数更少了，但是每次GC所用的时间增加了，从原来的0.03s变为0.19s 究其原因，东西多了，处理时间变长了自然也可以理解的。

对于串行GC而言，看着和并行GC差不多，随着内存的增大GC次数变少，并且GC时间边长，只是在耗时方面，串行GC似乎消耗的更多，毕竟是单核运行。